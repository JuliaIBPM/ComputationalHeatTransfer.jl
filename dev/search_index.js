var documenterSearchIndex = {"docs":
[{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"EditURL = \"../../../test/literate/heatconduction_dirichlet.jl\"","category":"page"},{"location":"manual/heatconduction_dirichlet/#Setting-up-a-time-varying-PDE","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"","category":"section"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"In this example we will demonstrate the use of the package on a time-dependent PDE, a problem of unsteady heat conduction. We will use the package to solve for the interior diffusion of temperature from a circle held at constant temperature.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"We seek to solve the heat conduction equation with Dirichlet boundary conditions","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"dfracpartial Tpartial t = kappa nabla^2 T + q + delta(chi) sigma  - kappa nablacdot left( delta(chi) mathbfn T right)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"subject to T = T_b on the immersed surface. We might be solving this external to a surface, or it might be internal. The quantity sigma is the Lagrange multiplier. In this context, it is the heat flux through the surface.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"In the spatially discrete formulation, the problem takes the form","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"beginbmatrix\nmathcalL_C^kappa  R_C  R_C^T  0\nendbmatrixbeginpmatrix\nT  -sigma\nendpmatrix =\nbeginpmatrix\nq - kappa D_s T  (T^+_b + T^-_b)2\nendpmatrix","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"where mathcalL_C^kappa = mathrmdmathrmdt - kappa L_C, where T = T_b^+ - T_b^- is the jump in temperature across the surface. As in the time-independent problems, we can specify whether we are solving it external or internal to a surface by setting the boundary value to zero in the other region. However, in contrast to the time-independent problems, we have to advance this problem in time. The system above has the form of a constrained ODE system, which the ConstrainedSystems.jl package treats. We will make use of this package in the example below.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"To support this, there are a few additional steps in our setup of the problem:","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"we (as the implementers of the PDE) need to specify the functions that calculate the  various parts of this constrained ODE system.\nwe (as the users of this implementation) need to specify the time step size,  the initial conditions, the time integration range, and create the integrator  to advance the solution.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The latter of these is very easy, as we'll find. Most of our attention will be on the first part: how to set up the constrained ODE system. For this, we will make use of the ODEFunctionList, which assembles the various functions and operators into a ConstrainedODEFunction, to be used by the ConstrainedSystems.jl package.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"using ComputationalHeatTransfer\nusing Plots","category":"page"},{"location":"manual/heatconduction_dirichlet/#Set-up-the-constrained-ODE-system-operators","page":"Setting up a time-varying PDE","title":"Set up the constrained ODE system operators","text":"","category":"section"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The problem type is generated with the usual macro call. In this example, we will make use of more of the capabilities of the resulting problem constructor for \"packing\" it with information about the problem.","category":"page"},{"location":"manual/heatconduction_dirichlet/#Solve-the-problem","page":"Setting up a time-varying PDE","title":"Solve the problem","text":"","category":"section"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"We will solve heat conduction inside a circular region with uniform temperature, with thermal diffusivity equal to 1.","category":"page"},{"location":"manual/heatconduction_dirichlet/#Set-up-the-grid","page":"Setting up a time-varying PDE","title":"Set up the grid","text":"","category":"section"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_dirichlet/#Set-up-the-body-shape.","page":"Setting up a time-varying PDE","title":"Set up the body shape.","text":"","category":"section"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Here, we will demonstrate the solution on a circular shape of radius 1.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Δs = 1.4*cellsize(g)\nbody = Circle(1.0,Δs);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Though the body is stationary, we still need to provide some minimal information about its placement and (lack of) motion. We do this with the help of the RigidBodyMotion structure. Technically, the placement of a body constitutes a basic joint with the inertial coordinate system. the MotionTransform below places the joint at the origin of the inertial coordinate system (the first argument), with no relative rotation (the second argument).","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"X = MotionTransform([0,0],0)\njoint = Joint(X)\nm = RigidBodyMotion(joint,body)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"We don't have to do anything more here because the placement of the body is trivial. However, to demonstrate how we might do it in other problems,","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"x = zero_motion_state(body,m)\nupdate_body!(body,x,m)","category":"page"},{"location":"manual/heatconduction_dirichlet/#Specify-the-physical-parameters,-data,-etc.","page":"Setting up a time-varying PDE","title":"Specify the physical parameters, data, etc.","text":"","category":"section"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"These can be changed later without having to regenerate the system.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Here, we create a dict with physical parameters to be passed in.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"phys_params = Dict(\"diffusivity\" => 1.0, \"Fourier\" => 1.0, \"lineheater_flux\" => 0.0, \"angular velocity\" => 0.0)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The temperature boundary functions on the exterior and interior are defined here and assembled into a dict. Note that these functions must have a slightly more complex signature than in time-invariant problems: for generality, they must accept the time argument and another argument accepting possible motions of the surfaces.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"get_Tbplus(t,x,base_cache,phys_params,motions) = zeros_surface(base_cache)\nget_Tbminus(t,x,base_cache,phys_params,motions) = ones_surface(base_cache)\nbcdict = Dict(\"exterior\" => get_Tbplus,\"interior\" => get_Tbminus)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Construct the problem, passing in the data and functions we've just created. We pass in the body's motion (however trivial) via the motions keyword. We run DirichletHeatConductionProblem.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"prob = DirichletHeatConductionProblem(g,body,scaling=GridScaling,\n                                             phys_params=phys_params,\n                                             bc=bcdict,\n                                             motions=m,\n                                             timestep_func=timestep_fourier);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Construct the system","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"sys = construct_system(prob);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_dirichlet/#Solving-the-problem","page":"Setting up a time-varying PDE","title":"Solving the problem","text":"","category":"section"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"In contrast to the previous (time-independent) example, we have not extended the solve function here to serve us in solving this problem. Instead, we rely on the tools in ConstrainedSystems.jl to advance the solution forward in time. This package builds from the OrdinaryDiffEq.jl package, and leverages most of the tools of that package.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Set an initial condition. Here, we just get an initial (zeroed) copy of the solution prototype that we have stored in the extra cache. We also get the time step size for our own inspection.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"u0 = init_sol(sys)\nΔt = timestep_fourier(u0,sys)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"It is instructive to note that u0 has two parts: a state and a constraint, each obtained respectively with a convenience function. The state in this case is the temperature; the constraint is the Lagrange multiplier.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"state(u0)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"constraint(u0)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Now, create the integrator, with a time interval of 0 to 1. We have not specified the algorithm here explicitly; it defaults to the LiskaIFHERK() time-marching algorithm, which is a second-order algorithm for constrained ODE systems that utilizes a matrix exponential (i.e., integrating factor) for the linear part of the problem (the Laplacian), and a half-explicit Runge-Kutta method for the constrained part. This method is most suitable for problems in which there is no dependence on the Lagrange multipliers in the constraint. (Such a problem is an index-2 differential-algebraic equation.) Another possible choice for this problem is the first-order Euler method, IFHEEuler(), which can be specified with the keyword alg=IFHEEuler().","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"For problems that do have a constraint that depends on the Lagrange multipliers such as the Neumann problem (in an upcoming example), then the default method switches to HETrapezoidalAB2(), which uses a half-explicit trapezoidal method for the constrained and linear parts, and 2nd-order Adams-Bashforth for the explicit part.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"tspan = (0.0,1.0)\nintegrator = init(u0,tspan,sys)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Now advance the solution by 0.01 convective time units, by using the step! function, which steps through the solution.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"step!(integrator,0.01)","category":"page"},{"location":"manual/heatconduction_dirichlet/#Plot-the-solution","page":"Setting up a time-varying PDE","title":"Plot the solution","text":"","category":"section"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The integrator holds the most recent solution in the field u, which has the same type as our initial condition u0. Here, we plot the state of the system at the end of the interval.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"plot(state(integrator.u),sys)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"It would be nice to just define a function called temperature to get this more explicitly. We will do that here, and also apply a macro @snapshotoutput that automatically extends this function with some convenient interfaces. For example, if we simply pass in the integrator to temperature, it will pick off the u field for us.","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"temperature(T,σ,x,sys::ILMSystem,t) = T\n@snapshotoutput temperature","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"Now we can write","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"plot(temperature(integrator),sys)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"The solution history is in the field integrator.sol. The macro we called earlier enables temperature to work for this, as well, and we can obtain the temperature at any time in the interval of our solution. For example, to get the solution at time 0.51:","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"sol = integrator.sol\nplot(temperature(sol,sys,0.0051),sys)","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"We can also get it for an array of times, e.g.,","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"temperature(sol,sys,0.0051:0.0001:0.0061);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"","category":"page"},{"location":"manual/heatconduction_dirichlet/","page":"Setting up a time-varying PDE","title":"Setting up a time-varying PDE","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/functions/#Functions-and-types","page":"Functions and types","title":"Functions and types","text":"","category":"section"},{"location":"manual/functions/#Functions","page":"Functions and types","title":"Functions","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Modules = [ComputationalHeatTransfer]\nOrder   = [:function]","category":"page"},{"location":"manual/functions/#Types","page":"Functions and types","title":"Types","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Modules = [ComputationalHeatTransfer]\nOrder   = [:type]","category":"page"},{"location":"manual/functions/#ComputationalHeatTransfer.DirichletHeatConductionProblem","page":"Functions and types","title":"ComputationalHeatTransfer.DirichletHeatConductionProblem","text":"DirichletHeatConductionProblem\n\nILM problem type dealing with scalar-type data.\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#ComputationalHeatTransfer.NeumannHeatConductionProblem","page":"Functions and types","title":"ComputationalHeatTransfer.NeumannHeatConductionProblem","text":"NeumannHeatConductionProblem\n\nILM problem type dealing with scalar-type data.\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#Index","page":"Functions and types","title":"Index","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"EditURL = \"../../../test/literate/heatconduction_neumann.jl\"","category":"page"},{"location":"manual/heatconduction_neumann/#Heat-conduction-with-Neumann-conditions","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"","category":"section"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"CurrentModule = ComputationalHeatTransfer","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"The immersed-layer heat equation is","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"dfracpartial overlineTpartial t = kappa nabla^2 overlineT - kappa nablacdot delta(chi) mathbfn T + delta(chi) q + q","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"where q = q^+_b - q^-_b = -kappa (partial T^+partial n - partial T^-partial n) and T = T_b^+ - T_b^-. It is important to note that, collectively,","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"kappa nabla^2 overlineT - kappa nablacdot delta(chi) mathbfn T + delta(chi) q","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"represents a modified version of the Laplacian operator: the second and third term \"fix\" the differencing of the first term across the discontinuity, replacing the values of overlineT across this discontinuity with the correct boundary values and boundary derivatives.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"The Neumann boundary condition is","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"-kappa mathbfn delta^T(chi)cdot nabla overlineT + kappa mathbfn delta^T(chi)cdotdelta(chi) mathbfn T = frac12 (q_b^+ + q_b^-)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"where q_b^pm are the heat fluxes through the immersed surface, e.g. q_b^+ = -kappa partial T^+partial n. The second term on the left side corrects the gradient of the masked temperature field overlineT, replacing the temperatures in this field across the discontinuity with the correct boundary values.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"When we discretize spatially, we introduce L for the Laplacian, D and G for divergence and gradient, respectively. Also, for shorthand let us denote R for delta(chi), and denote R_n for the discrete version of delta(chi)mathbfn, acting on surface scalars and regularizing them (multiplied by normal vectors) to a vector field on the grid. The transpose of this is R_n^T, the discrete version of mathbfn delta^T(chi)cdot.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"So we can write the discrete equations for overlineT and T as","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"fracmathrmd overlineTmathrmd t -kappa L overlineT + kappa DR_n T = q + Rq","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"-kappa R_n^T G overlineT + kappa R_n^TR_n T = overlineq","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"The matrix form is","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"beginbmatrix\nmathcalL_C^kappa  kappa D_s  -kappa G_s  kappa R_n^TR_n\nendbmatrixbeginpmatrix\nT  T\nendpmatrix =\nbeginpmatrix\nq + R q  (q^+_b + q^-_b)2\nendpmatrix","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"It is crucial that the time marching for solving this problem has a consistent time level among all terms in the \"modified\" Laplacian. In other words, if the Laplacian term is treated implicitly, then the other two terms must be, as well.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"using ComputationalHeatTransfer\nusing Plots","category":"page"},{"location":"manual/heatconduction_neumann/#Solve-the-problem","page":"Heat conduction with Neumann conditions","title":"Solve the problem","text":"","category":"section"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"We will solve heat conduction inside a square region with thermal diffusivity equal to 1. We will apply heating through the boundary and also introduce two different types of area heating regions in the interior.","category":"page"},{"location":"manual/heatconduction_neumann/#Set-up-the-grid","page":"Heat conduction with Neumann conditions","title":"Set up the grid","text":"","category":"section"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_neumann/#Set-up-the-body-shape.","page":"Heat conduction with Neumann conditions","title":"Set up the body shape.","text":"","category":"section"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Here, we will demonstrate the solution on a circular shape of radius 1.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Δs = 1.4*cellsize(g)\nbody = Square(1.0,Δs);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Stationary body","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"X = MotionTransform([0,0],0)\njoint = Joint(X)\nm = RigidBodyMotion(joint,body)\nx = zero_motion_state(body,m)\nupdate_body!(body,x,m)","category":"page"},{"location":"manual/heatconduction_neumann/#Specify-the-physical-parameters,-data,-etc.","page":"Heat conduction with Neumann conditions","title":"Specify the physical parameters, data, etc.","text":"","category":"section"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"These can be changed later without having to regenerate the system.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Here, we create a dict with physical parameters to be passed in.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"phys_params = Dict(\"diffusivity\" => 1.0,\n                    \"Fourier\" => 1.0,\n                    \"areaheater_flux\" => 10.0,\n                    \"areaheater_freq\" => 1.0,\n                     \"areaheater_temp\" => 1.0,\n                     \"areaheater_coeff\" => 10.0)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Define the heating region functions. We will create one heating region with prescribed heat flux and another with a target temperature","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"fregion1 = Circle(0.2,1.4*Δx)\ntr1 = MotionTransform((0.0,-0.7),0.0)\n\nfunction model1!(σ,T,t,fr::AreaRegionCache,phys_params)\n    σ .= phys_params[\"areaheater_flux\"]\nend\nafm1 = AreaForcingModel(fregion1,tr1,model1!)\n\nfregion2 = Circle(0.2,1.4*Δx)\ntr2 = RigidTransform((-0.7,0.7),0.0)\n\nfunction model2!(σ,T,t,fr::AreaRegionCache,phys_params)\n    f = phys_params[\"areaheater_freq\"]\n    T0 = phys_params[\"areaheater_temp\"]\n    h = phys_params[\"areaheater_coeff\"]\n    σ .= h*(T0 - T)\nend\nafm2 = AreaForcingModel(fregion2,tr2,model2!);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Plot the heating regions","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"plot(body,fill=false)\nupdate_body!(fregion1,tr1)\nupdate_body!(fregion2,tr2)\nplot!(fregion1)\nplot!(fregion2)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Pack them together","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"forcing_dict = Dict(\"heating models\" => AbstractForcingModel[afm1,afm2])","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"The heat flux boundary functions on the exterior and interior are defined here and assembled into a dict. Note that we are using the x component of the normal for the interior boundary heat flux. This sets non-zero heat fluxes through the vertical boundaries (inward on the left, outward on the right), and adiabatic conditions on the top and bottom.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"function get_qbplus(t,x,base_cache,phys_params,motions)\n    nrm = normals(base_cache)\n    qbplus = zeros_surface(base_cache)\n    return qbplus\nend\n\nfunction get_qbminus(t,x,base_cache,phys_params,motions)\n    nrm = normals(base_cache)\n    qbminus = zeros_surface(base_cache)\n    qbminus .= nrm.u\n    return qbminus\nend\n\nbcdict = Dict(\"exterior\" => get_qbplus,\"interior\" => get_qbminus)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Construct the problem, passing in the data and functions we've just created. We pass in the body's motion (however trivial) via the motions keyword. We run NeumannHeatConductionProblem.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"prob = NeumannHeatConductionProblem(g,body,scaling=GridScaling,\n                                             phys_params=phys_params,\n                                             bc=bcdict,\n                                             motions=m,\n                                             forcing=forcing_dict,\n                                             timestep_func=timestep_fourier);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Construct the system","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"sys = construct_system(prob);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_neumann/#Solving-the-problem","page":"Heat conduction with Neumann conditions","title":"Solving the problem","text":"","category":"section"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Set an initial condition. Here, we just get an initial (zeroed) copy of the solution prototype that we have stored in the extra cache. We also get the time step size for our own inspection.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"u0 = init_sol(sys)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Now, create the integrator, with a time interval of 0 to 1. This uses the HETrapezoidalAB2() method, by default, since it has a constraint that depends on the Lagrange multipliers.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"tspan = (0.0,1.0)\nintegrator = init(u0,tspan,sys)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Now advance the solution by 0.01 convective time units, by using the step! function, which steps through the solution.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"step!(integrator,0.01)","category":"page"},{"location":"manual/heatconduction_neumann/#Plot-the-solution","page":"Heat conduction with Neumann conditions","title":"Plot the solution","text":"","category":"section"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"First, create the temperature function that allows us to easily plot.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"temperature(T,σ,x,sys::ILMSystem,t) = T\n@snapshotoutput temperature","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Now plot","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"plot(temperature(integrator),sys)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"and the Lagrange multiplier (the constraint)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"plot(constraint(integrator.u))","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Plot a slice across the domain. To do so, we make use of the interpolatable_field function, which creates a functional version of the temperature field that we can access like a spatial field, e.g. T(xy).","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Tfcn = interpolatable_field(temperature(integrator),sys);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"First, a vertical slice along x=0, to verify that the adiabatic conditions are met there.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"y = -2:0.01:2\nplot(Tfcn(0,y),y,xlabel=\"T(0,y)\",ylabel=\"y\",legend=false)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"Now, a horizontal slice along y=0, to verify that the adiabatic conditions are met there.","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"x = -2:0.01:2\nplot(x,Tfcn(x,0),xlabel=\"x\",ylabel=\"T(x,0)\",legend=false)","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"","category":"page"},{"location":"manual/heatconduction_neumann/","page":"Heat conduction with Neumann conditions","title":"Heat conduction with Neumann conditions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"EditURL = \"../../../test/literate/heatconduction_unbounded.jl\"","category":"page"},{"location":"manual/heatconduction_unbounded/#A-time-varying-PDE-with-forcing","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"","category":"section"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"CurrentModule = ImmersedLayers","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"In a previous example of the Poisson equation we demonstrated the use of point forcing. In this example we will explore other ways to apply forcing to a PDE. Our target problem will be similar to the most recent example – transient heat conduction – but now it will be in an unbounded domain. Our forcing will comprise local area heating and line heating. We will also include convection by an externally-imposed velocity field.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"The governing equations are","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"dfracpartial Tpartial t + mathbfvcdotnabla T = kappa nabla^2 T + q","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"where mathbfv is a known convection velocity field and q is a known heating field (scaled by the density and specific heat)","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"In our discrete formulation, the problem takes the form","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"mathcalL_C^kappa T = -N(mathbfvT) + q","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"where N is a discrete approximation for the convection term mathbfvcdotnabla T, and mathcalL_C^kappa = mathrmdmathrmdt - kappa L_C is the same diffusion operator as in the previous example. Note that these equations are no longer constrained. We only need to supply the right-hand side function. Our job here is to provide everything needed to compute this right-hand side.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We will apply the heating and cooling inside of local regions. As we discussed before, for each forcing, we supply information about the shape of the forcing region and the model function, supplying the forcing strength whenever we need it. We package these together into a forcing model and provide it to the problem via the forcing keyword.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"The convection velocity also must be provided. We also make use of the forcing keyword to supply this to the problem, as well, in the form of a function that returns the current convection velocity at a given time t. The convective derivative term N requires a special cache, which we also generate in the prob_cache.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We will highlight these aspects in the example that follows. In this example, we will create","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"a square-shaped line forcing region that delivers a certain amount of heat per unit length of line\na circular-shaped area forcing region that supplies heat based on the heat-transfer model hcdot(T_0cos(2pi f t)-T), where h is the heat transfer coefficient, T is the current local temperature,","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"and T_0 is the amplitude of an oscillatory heater temperature, oscillating at frequency f","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"a background rotational velocity field, with angular velocity Omega.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"using ComputationalHeatTransfer\nusing Plots","category":"page"},{"location":"manual/heatconduction_unbounded/#Set-up-the-grid","page":"A time-varying PDE with forcing","title":"Set up the grid","text":"","category":"section"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Let's set up the grid first before we go any further","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Δx = 0.01\nLx = 4.0\nxlim = (-Lx/2,Lx/2)\nylim = (-Lx/2,Lx/2)\ng = PhysicalGrid(xlim,ylim,Δx);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_unbounded/#Specify-the-physical-parameters","page":"A time-varying PDE with forcing","title":"Specify the physical parameters","text":"","category":"section"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We supply here the diffusivity (kappa) and the uniform convection velocity. We also supply the grid Fourier number and a CFL number, which we will make use of later to calculate the time step size.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"phys_params = Dict(\"diffusivity\" => 0.005,\n                    \"angular velocity\" => 0.5,\n                    \"length scale\" => Lx/2,\n                     \"Fourier\" => 1.0,\n                     \"CFL\" => 0.5,\n                     \"lineheater_flux\" => -2.0,\n                     \"areaheater_freq\" => 1.0,\n                     \"areaheater_temp\" => 2.0,\n                     \"areaheater_coeff\" => 100.0\n                     )","category":"page"},{"location":"manual/heatconduction_unbounded/#Specifying-the-forcing-regions-and-models-and-convection-velocity-model","page":"A time-varying PDE with forcing","title":"Specifying the forcing regions and models and convection velocity model","text":"","category":"section"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We first create the square line heater and place it at (01). Its associated model function is very simple, since it just sets the strength uniformly. But note the function signature, which must always take this form. It can make use of the current temperature, time, and physical parameters, to return the strength of the line forcing. We bundle these together using LineForcingModel.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"fregion1 = Square(0.5,1.4*Δx)\ntr1 = RigidTransform((0.0,1.0),0.0)\n\nfunction model1!(σ,T,t,fr::LineRegionCache,phys_params)\n    σ .= phys_params[\"lineheater_flux\"]\nend\nlfm = LineForcingModel(fregion1,tr1,model1!);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Now the oscillatory heater, which we place at (0-05). This one has a few more parameters, since we provide the heat transfer coefficient and the amplitude and frequency of the target temperature. These are bundled with AreaForcingModel.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"fregion2 = Circle(0.2,1.4*Δx)\ntr2 = RigidTransform((0.0,-0.5),0.0)\n\nfunction model2!(σ,T,t,fr::AreaRegionCache,phys_params)\n    f = phys_params[\"areaheater_freq\"]\n    T0 = phys_params[\"areaheater_temp\"]\n    h = phys_params[\"areaheater_coeff\"]\n    σ .= h*(T0*cos(2π*f*t) - T)\nend\nafm = AreaForcingModel(fregion2,tr2,model2!);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Finally, the convection velocity model. Here, we make use of the coordinate function x_gridgrad and y_gridgrad to supply the coordinates of the velocity grid points. Since this is a staggered grid, the velocity components live at different places. For example, yg.u denotes the y coordinates for the horizontal velocity components, and xg.v denotes the x coordinates for the vertical velocity components.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"function my_velocity!(vel,t,cache,phys_params)\n    xg, yg = x_gridgrad(cache), y_gridgrad(cache)\n    Ω = phys_params[\"angular velocity\"]\n    vel.u .= -Ω*yg.u\n    vel.v .= Ω*xg.v\n    return vel\nend","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"As in the last example, we also define the temperature output function for output","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"temperature(T,σ,x,sys::ILMSystem,t) = T\n@snapshotoutput temperature","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"We pack the forcing and convection together into the forcing Dict.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"forcing_dict = Dict(\"heating models\" => [lfm,afm],\n                    \"convection velocity model\" => my_velocity!)","category":"page"},{"location":"manual/heatconduction_unbounded/#Set-up-the-problem-and-system","page":"A time-varying PDE with forcing","title":"Set up the problem and system","text":"","category":"section"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"This is similar to previous problems. Note that we treat it as a Dirichlet problem, even though there is no boundary.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"prob = DirichletHeatConductionProblem(g,scaling=GridScaling,\n                                        phys_params=phys_params,\n                                        forcing=forcing_dict,\n                                        timestep_func=timestep_fourier_cfl)\n\nsys = construct_system(prob);\nnothing #hide","category":"page"},{"location":"manual/heatconduction_unbounded/#Solve-the-problem","page":"A time-varying PDE with forcing","title":"Solve the problem","text":"","category":"section"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"As before, we first initialize the state, then we create an integrator, and finally, advance the solution in time","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"u0 = init_sol(sys)\ntspan = (0.0,2.0)\nintegrator = init(u0,tspan,sys)","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Run the problem for one time unit","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"step!(integrator,1.0)","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"Let's see what this looks like. We will plot a set of snapshots in an array.","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"sol = integrator.sol\n\nplt = plot(layout = (2,3), size = (700, 500), legend=:false)\nfor (i,t) in enumerate(0:0.2:1.0)\n   plot!(plt[i],temperature(sol,sys,t),sys,levels=range(-10,2,length=30),clim=(-10,2))\nend\nplt","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"","category":"page"},{"location":"manual/heatconduction_unbounded/","page":"A time-varying PDE with forcing","title":"A time-varying PDE with forcing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ComputationalHeatTransfer.jl","page":"Home","title":"ComputationalHeatTransfer.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"*a framework for simulating heat transfer in complex geometries *","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to allow easy setup and fast simulation of heat transfer, particularly in complex geometries. The package provides tools for","category":"page"},{"location":"","page":"Home","title":"Home","text":"constructing grids, body shapes, and heating/cooling regions,\nspecifying the relevant parameters and setting their values,\nsolving the problem, and finally,\nvisualizing and analyzing the results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying grids are uniform and Cartesian, making use of the CartesianGrids package. This package allows the use of the lattice Green's function (LGF) for inverting the Poisson equation; the diffusion operators are solved with the integrating factor (Liska and Colonius [2]). Many of the core aspects of the fluid-body interaction are based on the Method of Immersed Layers [1], ImmersedLayers, which is an extension of the immersed boundary projection method [3]. The solver is implemented with the ConstrainedSystems package. Tools for creating bodies and their motions are based on the RigidBodyTools package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package works on Julia 1.6 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ComputationalHeatTransfer","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ComputationalHeatTransfer","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Eldredge, J. D. (2022) \"A method of immersed layers on Cartesian grids, with application to incompressible flows,\" Journal of Computational Physics 448: 110716.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Liska, S. and Colonius, T. (2017) \"A fast immersed boundary method for external incompressible viscous flows using lattice Green's functions,\" J. Comput. Phys., 331, 257–279.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Taira, K. and Colonius, T. (2007) \"The immersed boundary method: a projection approach,\" J. Comput. Phys., 225, 2118–2137.","category":"page"}]
}
