<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heat conduction with Neumann conditions · ComputationalHeatTransfer.jl</title><meta name="title" content="Heat conduction with Neumann conditions · ComputationalHeatTransfer.jl"/><meta property="og:title" content="Heat conduction with Neumann conditions · ComputationalHeatTransfer.jl"/><meta property="twitter:title" content="Heat conduction with Neumann conditions · ComputationalHeatTransfer.jl"/><meta name="description" content="Documentation for ComputationalHeatTransfer.jl."/><meta property="og:description" content="Documentation for ComputationalHeatTransfer.jl."/><meta property="twitter:description" content="Documentation for ComputationalHeatTransfer.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ComputationalHeatTransfer.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../heatconduction_dirichlet/">Setting up a time-varying PDE</a></li><li class="is-active"><a class="tocitem" href>Heat conduction with Neumann conditions</a><ul class="internal"><li><a class="tocitem" href="#Solve-the-problem"><span>Solve the problem</span></a></li></ul></li><li><a class="tocitem" href="../heatconduction_unbounded/">A time-varying PDE with forcing</a></li><li><a class="tocitem" href="../functions/">Functions and types</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Heat conduction with Neumann conditions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Heat conduction with Neumann conditions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ComputationalHeatTransfer.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/ComputationalHeatTransfer.jl/blob/main/test/literate/heatconduction_neumann.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Heat-conduction-with-Neumann-conditions"><a class="docs-heading-anchor" href="#Heat-conduction-with-Neumann-conditions">Heat conduction with Neumann conditions</a><a id="Heat-conduction-with-Neumann-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Heat-conduction-with-Neumann-conditions" title="Permalink"></a></h1><p>The immersed-layer heat equation is</p><p class="math-container">\[\dfrac{\partial \overline{T}}{\partial t} = \kappa \nabla^2 \overline{T} - \kappa \nabla\cdot \delta(\chi) \mathbf{n} [T] + \delta(\chi) [q] + q&#39;&#39;\]</p><p>where <span>$[q] = q^+_b - q^-_b = -\kappa (\partial T^+/\partial n - \partial T^-/\partial n)$</span> and <span>$[T] = T_b^+ - T_b^-$</span>. It is important to note that, collectively,</p><p class="math-container">\[\kappa \nabla^2 \overline{T} - \kappa \nabla\cdot \delta(\chi) \mathbf{n} [T] + \delta(\chi) [q]\]</p><p>represents a modified version of the Laplacian operator: the second and third term &quot;fix&quot; the differencing of the first term across the discontinuity, replacing the values of <span>$\overline{T}$</span> across this discontinuity with the correct boundary values and boundary derivatives.</p><p>The Neumann boundary condition is</p><p class="math-container">\[-\kappa \mathbf{n} \delta^{T}(\chi)\cdot \nabla \overline{T} + \kappa \mathbf{n} \delta^T(\chi)\cdot\delta(\chi) \mathbf{n} [T] = \frac{1}{2} (q_b^+ + q_b^-)\]</p><p>where <span>$q_b^\pm$</span> are the heat fluxes through the immersed surface, e.g. <span>$q_b^+ = -\kappa \partial T^+/\partial n$</span>. The second term on the left side corrects the gradient of the masked temperature field <span>$\overline{T}$</span>, replacing the temperatures in this field across the discontinuity with the correct boundary values.</p><p>When we discretize spatially, we introduce <span>$L$</span> for the Laplacian, <span>$D$</span> and <span>$G$</span> for divergence and gradient, respectively. Also, for shorthand let us denote <span>$R$</span> for <span>$\delta(\chi)$</span>, and denote <span>$R_n$</span> for the discrete version of <span>$\delta(\chi)\mathbf{n}$</span>, acting on surface scalars and regularizing them (multiplied by normal vectors) to a vector field on the grid. The transpose of this is <span>$R_n^T$</span>, the discrete version of <span>$\mathbf{n} \delta^{T}(\chi)\cdot$</span>.</p><p>So we can write the discrete equations for <span>$\overline{T}$</span> and <span>$[T]$</span> as</p><p class="math-container">\[\frac{\mathrm{d} \overline{T}}{\mathrm{d} t} -\kappa L \overline{T} + \kappa DR_n [T] = q + R[q]\]</p><p class="math-container">\[-\kappa R_n^T G \overline{T} + \kappa R_n^TR_n [T] = \overline{q}\]</p><p>The matrix form is</p><p class="math-container">\[\begin{bmatrix}
\mathcal{L}_C^\kappa &amp; \kappa D_s \\ -\kappa G_s &amp; \kappa R_n^TR_n
\end{bmatrix}\begin{pmatrix}
T \\ [T]
\end{pmatrix} =
\begin{pmatrix}
q + R [q] \\ (q^+_b + q^-_b)/2
\end{pmatrix}\]</p><p>It is crucial that the time marching for solving this problem has a consistent time level among all terms in the &quot;modified&quot; Laplacian. In other words, if the Laplacian term is treated implicitly, then the other two terms must be, as well.</p><pre><code class="language-julia hljs">using ComputationalHeatTransfer
using Plots</code></pre><h2 id="Solve-the-problem"><a class="docs-heading-anchor" href="#Solve-the-problem">Solve the problem</a><a id="Solve-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-problem" title="Permalink"></a></h2><p>We will solve heat conduction inside a square region with thermal diffusivity equal to 1. We will apply heating through the boundary and also introduce two different types of area heating regions in the interior.</p><h3 id="Set-up-the-grid"><a class="docs-heading-anchor" href="#Set-up-the-grid">Set up the grid</a><a id="Set-up-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-grid" title="Permalink"></a></h3><pre><code class="language-julia hljs">Δx = 0.01
Lx = 4.0
xlim = (-Lx/2,Lx/2)
ylim = (-Lx/2,Lx/2)
g = PhysicalGrid(xlim,ylim,Δx);</code></pre><h3 id="Set-up-the-body-shape."><a class="docs-heading-anchor" href="#Set-up-the-body-shape.">Set up the body shape.</a><a id="Set-up-the-body-shape.-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-body-shape." title="Permalink"></a></h3><p>Here, we will demonstrate the solution on a circular shape of radius 1.</p><pre><code class="language-julia hljs">Δs = 1.4*cellsize(g)
body = Square(1.0,Δs);</code></pre><p>Stationary body</p><pre><code class="language-julia hljs">X = MotionTransform([0,0],0)
joint = Joint(X)
m = RigidBodyMotion(joint,body)
x = zero_motion_state(body,m)
update_body!(body,x,m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Closed polygon with 4 vertices and 572 points
   Current position: (0.0,0.0)
   Current angle (rad): 0.0
</code></pre><h3 id="Specify-the-physical-parameters,-data,-etc."><a class="docs-heading-anchor" href="#Specify-the-physical-parameters,-data,-etc.">Specify the physical parameters, data, etc.</a><a id="Specify-the-physical-parameters,-data,-etc.-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-the-physical-parameters,-data,-etc." title="Permalink"></a></h3><p>These can be changed later without having to regenerate the system.</p><p>Here, we create a dict with physical parameters to be passed in.</p><pre><code class="language-julia hljs">phys_params = Dict(&quot;diffusivity&quot; =&gt; 1.0,
                    &quot;Fourier&quot; =&gt; 1.0,
                    &quot;areaheater_flux&quot; =&gt; 10.0,
                    &quot;areaheater_freq&quot; =&gt; 1.0,
                     &quot;areaheater_temp&quot; =&gt; 1.0,
                     &quot;areaheater_coeff&quot; =&gt; 10.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Float64} with 6 entries:
  &quot;areaheater_coeff&quot; =&gt; 10.0
  &quot;Fourier&quot;          =&gt; 1.0
  &quot;areaheater_temp&quot;  =&gt; 1.0
  &quot;diffusivity&quot;      =&gt; 1.0
  &quot;areaheater_freq&quot;  =&gt; 1.0
  &quot;areaheater_flux&quot;  =&gt; 10.0</code></pre><p>Define the heating region functions. We will create one heating region with prescribed heat flux and another with a target temperature</p><pre><code class="language-julia hljs">fregion1 = Circle(0.2,1.4*Δx)
tr1 = MotionTransform((0.0,-0.7),0.0)

function model1!(σ,T,t,fr::AreaRegionCache,phys_params)
    σ .= phys_params[&quot;areaheater_flux&quot;]
end
afm1 = AreaForcingModel(fregion1,tr1,model1!)

fregion2 = Circle(0.2,1.4*Δx)
tr2 = RigidTransform((-0.7,0.7),0.0)

function model2!(σ,T,t,fr::AreaRegionCache,phys_params)
    f = phys_params[&quot;areaheater_freq&quot;]
    T0 = phys_params[&quot;areaheater_temp&quot;]
    h = phys_params[&quot;areaheater_coeff&quot;]
    σ .= h*(T0 - T)
end
afm2 = AreaForcingModel(fregion2,tr2,model2!);</code></pre><p>Plot the heating regions</p><pre><code class="language-julia hljs">plot(body,fill=false)
update_body!(fregion1,tr1)
update_body!(fregion2,tr2)
plot!(fregion1)
plot!(fregion2)</code></pre><img src="1b208219.svg" alt="Example block output"/><p>Pack them together</p><pre><code class="language-julia hljs">forcing_dict = Dict(&quot;heating models&quot; =&gt; AbstractForcingModel[afm1,afm2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Vector{AbstractForcingModel}} with 1 entry:
  &quot;heating models&quot; =&gt; [AreaForcingModel{Ellipse{88}, MotionTransform{2}, typeof…</code></pre><p>The heat flux boundary functions on the exterior and interior are defined here and assembled into a dict. Note that we are using the <span>$x$</span> component of the normal for the interior boundary heat flux. This sets non-zero heat fluxes through the vertical boundaries (inward on the left, outward on the right), and adiabatic conditions on the top and bottom.</p><pre><code class="language-julia hljs">function get_qbplus(t,x,base_cache,phys_params,motions)
    nrm = normals(base_cache)
    qbplus = zeros_surface(base_cache)
    return qbplus
end

function get_qbminus(t,x,base_cache,phys_params,motions)
    nrm = normals(base_cache)
    qbminus = zeros_surface(base_cache)
    qbminus .= nrm.u
    return qbminus
end

bcdict = Dict(&quot;exterior&quot; =&gt; get_qbplus,&quot;interior&quot; =&gt; get_qbminus)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, Function} with 2 entries:
  &quot;interior&quot; =&gt; get_qbminus
  &quot;exterior&quot; =&gt; get_qbplus</code></pre><p>Construct the problem, passing in the data and functions we&#39;ve just created. We pass in the body&#39;s motion (however trivial) via the <code>motions</code> keyword. We run <code>NeumannHeatConductionProblem</code>.</p><pre><code class="language-julia hljs">prob = NeumannHeatConductionProblem(g,body,scaling=GridScaling,
                                             phys_params=phys_params,
                                             bc=bcdict,
                                             motions=m,
                                             forcing=forcing_dict,
                                             timestep_func=timestep_fourier);</code></pre><p>Construct the system</p><pre><code class="language-julia hljs">sys = construct_system(prob);</code></pre><h3 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h3><p>Set an initial condition. Here, we just get an initial (zeroed) copy of the solution prototype that we have stored in the extra cache. We also get the time step size for our own inspection.</p><pre><code class="language-julia hljs">u0 = init_sol(sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Primal nodes in a (nx = 405, ny = 405) cell grid of type Float64 data
  Number of Primal nodes: (nx = 404, ny = 404), [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0])</code></pre><p>Now, create the integrator, with a time interval of 0 to 1. This uses the <code>HETrapezoidalAB2()</code> method, by default, since it has a constraint that depends on the Lagrange multipliers.</p><pre><code class="language-julia hljs">tspan = (0.0,1.0)
integrator = init(u0,tspan,sys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">t: 0.0
u: (Primal nodes in a (nx = 405, ny = 405) cell grid of type Float64 data
  Number of Primal nodes: (nx = 404, ny = 404), [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0])</code></pre><p>Now advance the solution by 0.01 convective time units, by using the <code>step!</code> function, which steps through the solution.</p><pre><code class="language-julia hljs">step!(integrator,0.01)</code></pre><h3 id="Plot-the-solution"><a class="docs-heading-anchor" href="#Plot-the-solution">Plot the solution</a><a id="Plot-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-the-solution" title="Permalink"></a></h3><p>First, create the temperature function that allows us to easily plot.</p><pre><code class="language-julia hljs">temperature(T,σ,x,sys::ILMSystem,t) = T
@snapshotoutput temperature</code></pre><p>Now plot</p><pre><code class="language-julia hljs">plot(temperature(integrator),sys)</code></pre><img src="86f1d52a.svg" alt="Example block output"/><p>and the Lagrange multiplier (the constraint)</p><pre><code class="language-julia hljs">plot(constraint(integrator.u))</code></pre><img src="c55eb30f.svg" alt="Example block output"/><p>Plot a slice across the domain. To do so, we make use of the <code>interpolatable_field</code> function, which creates a functional version of the temperature field that we can access like a spatial field, e.g. <span>$T(x,y)$</span>.</p><pre><code class="language-julia hljs">Tfcn = interpolatable_field(temperature(integrator),sys);</code></pre><p>First, a vertical slice along <span>$x=0$</span>, to verify that the adiabatic conditions are met there.</p><pre><code class="language-julia hljs">y = -2:0.01:2
plot(Tfcn(0,y),y,xlabel=&quot;T(0,y)&quot;,ylabel=&quot;y&quot;,legend=false)</code></pre><img src="944a5299.svg" alt="Example block output"/><p>Now, a horizontal slice along <span>$y=0$</span>, to verify that the adiabatic conditions are met there.</p><pre><code class="language-julia hljs">x = -2:0.01:2
plot(x,Tfcn(x,0),xlabel=&quot;x&quot;,ylabel=&quot;T(x,0)&quot;,legend=false)</code></pre><img src="7f808e95.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../heatconduction_dirichlet/">« Setting up a time-varying PDE</a><a class="docs-footer-nextpage" href="../heatconduction_unbounded/">A time-varying PDE with forcing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 22 April 2025 17:16">Tuesday 22 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
